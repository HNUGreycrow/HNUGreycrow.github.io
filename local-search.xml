<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Docker常用命令</title>
    <link href="/2025/08/13/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2025/08/13/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker常用命令学习笔记"><a href="#Docker常用命令学习笔记" class="headerlink" title="Docker常用命令学习笔记"></a>Docker常用命令学习笔记</h1><p>整理了 Docker 核心命令的用法，从服务管理到容器操作，方便后续复习查阅。</p><h2 id="服务命令"><a href="#服务命令" class="headerlink" title="服务命令"></a>服务命令</h2><h3 id="启动Docker服务"><a href="#启动Docker服务" class="headerlink" title="启动Docker服务"></a>启动Docker服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl start docker<br></code></pre></td></tr></table></figure><p><strong>功能</strong>：启动 Docker 守护进程（dockerd），使 Docker 服务进入运行状态。</p><p><strong>说明</strong>：执行后 Docker 服务将在后台运行，支持后续的镜像拉取、容器创建等操作。若启动失败，可通过<code>journalctl -u docker</code>查看错误日志。</p><h3 id="停止Docker服务"><a href="#停止Docker服务" class="headerlink" title="停止Docker服务"></a>停止Docker服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl stop docker<br></code></pre></td></tr></table></figure><p><strong>功能</strong>：终止 Docker 守护进程及所有正在运行的容器。</p><p><strong>注意</strong>：停止服务前建议先手动停止重要容器，避免数据未持久化导致丢失。</p><h3 id="重启Docker服务"><a href="#重启Docker服务" class="headerlink" title="重启Docker服务"></a>重启Docker服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl restart docker<br></code></pre></td></tr></table></figure><p><strong>功能</strong>：先停止再启动 Docker 服务，常用于配置文件修改后生效（如&#x2F;etc&#x2F;docker&#x2F;daemon.json）。</p><p><strong>适用场景</strong>：修改 Docker 镜像源、调整存储驱动等配置后，需重启服务使变更生效。</p><h3 id="查看Docker服务状态"><a href="#查看Docker服务状态" class="headerlink" title="查看Docker服务状态"></a>查看Docker服务状态</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl status docker<br></code></pre></td></tr></table></figure><p><strong>功能</strong>：显示 Docker 服务的当前状态（运行中 &#x2F; 已停止 &#x2F; 故障等）及最近的运行日志。</p><p><strong>输出说明</strong>：</p><ul><li><p>绿色active (running)表示服务正常运行；</p></li><li><p>红色inactive (dead)表示服务已停止；</p></li><li><p>日志部分可查看服务启动失败的具体原因。</p></li></ul><h2 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h2><h3 id="查看镜像列表"><a href="#查看镜像列表" class="headerlink" title="查看镜像列表"></a>查看镜像列表</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker images<br>docker images -q <span class="hljs-comment"># 查看所有镜像ID</span><br></code></pre></td></tr></table></figure><p><strong>功能</strong>：列出本地存储的所有 Docker 镜像。</p><p><strong>输出字段说明</strong>：</p><ul><li><p>REPOSITORY：镜像名称（含仓库地址，如nginx默认指向 Docker Hub 官方仓库）；</p></li><li><p>TAG：镜像版本标签（如latest表示最新版本）；</p></li><li><p>IMAGE ID：镜像唯一标识符（64 位哈希值的前 12 位）；</p></li><li><p>SIZE：镜像占用的存储空间。</p></li></ul><p><strong>参数说明</strong>：-q（quiet）仅输出镜像 ID，常用于批量操作（如docker rmi $(docker images -q)删除所有镜像）。</p><h3 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull &lt;镜像名称&gt;<br></code></pre></td></tr></table></figure><p><strong>功能</strong>：从远程镜像仓库（默认 Docker Hub）下载镜像到本地。</p><p><strong>格式说明</strong>：</p><ul><li><p>完整镜像名称格式为仓库地址&#x2F;用户名&#x2F;镜像名:标签，例如docker pull mysql:8.0表示拉取 MySQL 8.0 版本；</p></li><li><p>省略标签时默认拉取latest版本，但生产环境建议指定具体版本以避免兼容性问题。</p></li></ul><p><strong>示例</strong>：docker pull nginx:1.23 拉取 Nginx 1.23 稳定版镜像。</p><h3 id="搜索镜像"><a href="#搜索镜像" class="headerlink" title="搜索镜像"></a>搜索镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker search &lt;镜像名称&gt;<br></code></pre></td></tr></table></figure><p><strong>功能</strong>：在 Docker Hub 中搜索符合关键词的镜像。</p><p><strong>输出说明</strong>：</p><ul><li>STARS：镜像的受欢迎程度（星星数量）；</li><li>OFFICIAL：是否为官方维护的镜像（OK表示官方镜像，安全性更高）；</li><li>AUTOMATED：是否为自动构建的镜像。</li></ul><p><strong>问题</strong>：<strong>Error response from daemon: Get “<code>https://index.docker.io/v1/search?q=nginx&amp;n=25</code>“: dial tcp 108.160.166.142:443: i&#x2F;o timeout</strong></p><p>有可能是因为网络的问题，搜索总是失败。</p><h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker rmi &lt;镜像ID/名称&gt;<br></code></pre></td></tr></table></figure><p><strong>功能</strong>：删除本地指定的镜像。</p><p><strong>注意事项</strong>：</p><ul><li><p>若镜像已被容器引用（即使容器已停止），需先删除关联容器才能删除镜像；</p></li><li><p>可通过-f参数强制删除（docker rmi -f &lt;镜像ID&gt;），但不建议强制操作以免数据残留。</p></li></ul><h3 id="查看镜像详情"><a href="#查看镜像详情" class="headerlink" title="查看镜像详情"></a>查看镜像详情</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker inspect &lt;镜像ID&gt;<br></code></pre></td></tr></table></figure><p><strong>功能</strong>：显示镜像的完整元数据，包括构建历史、环境变量、存储层信息等。</p><p><strong>适用场景</strong>：排查镜像配置问题（如默认工作目录、暴露端口），或获取镜像的详细构建信息。</p><h2 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h2><h3 id="查看容器列表"><a href="#查看容器列表" class="headerlink" title="查看容器列表"></a>查看容器列表</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker ps <span class="hljs-comment"># 查看正在运行的容器</span><br>docker ps -a <span class="hljs-comment"># 查看所有容器，包括已停止的容器</span><br>docker ps -q <span class="hljs-comment"># 查看所有容器ID</span><br></code></pre></td></tr></table></figure><p><strong>功能</strong>：列出当前系统中的容器状态。</p><p><strong>参数说明</strong>：</p><ul><li><p>不加参数默认显示运行中容器；</p></li><li><p>-a（all）显示所有容器（包括已停止、已退出的）；</p></li><li><p>-q（quiet）仅输出容器 ID，便于批量操作（如docker stop $(docker ps -q)停止所有运行中容器）。</p></li></ul><p><strong>输出字段</strong>：CONTAINER ID（容器 ID）、STATUS（状态，如Up 5 minutes表示运行 5 分钟）等。</p><h3 id="创建并启动容器"><a href="#创建并启动容器" class="headerlink" title="创建并启动容器"></a>创建并启动容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run &lt;镜像名称&gt;<br></code></pre></td></tr></table></figure><p><strong>功能</strong>：基于指定镜像创建并启动一个新容器。</p><p><strong>常用参数</strong>：</p><ul><li><p>-it：以交互式终端模式运行（常用于需要手动操作的场景，如docker run -it ubuntu &#x2F;bin&#x2F;bash进入 Ubuntu 容器的命令行）；</p></li><li><p>-t：为容器重新分配一个伪输入终端，通常和-i同时使用；</p></li><li><p>-d：后台运行，启动后不会占着终端（但得用<code>exec</code>才能进去）；</p></li><li><p>-p：端口映射（如-p 8080:80将容器的 80 端口映射到主机的 8080 端口）；</p></li><li><p>–name：指定容器名称（如–name my-nginx避免使用随机生成的名称）。</p></li></ul><h3 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker start &lt;容器ID/名称&gt;<br></code></pre></td></tr></table></figure><p><strong>功能</strong>：启动已停止的容器（容器未被删除时有效）。</p><p><strong>说明</strong>：容器启动后会沿用创建时的配置（如端口映射、挂载目录），状态恢复为运行中。</p><h3 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> 参数<br></code></pre></td></tr></table></figure><p><strong>功能</strong>：在运行中的容器内执行命令，常用于进入容器终端进行操作。</p><p><strong>示例</strong>：docker exec -it my-nginx &#x2F;bin&#x2F;bash 进入名称为my-nginx的容器并启动 bash 终端。</p><p><strong>参数说明</strong>：</p><ul><li><p>-i：保持标准输入打开；</p></li><li><p>-t：分配伪终端，两者结合实现交互式操作。</p></li></ul><h3 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker stop &lt;容器ID/名称&gt;<br></code></pre></td></tr></table></figure><p><strong>功能</strong>：优雅停止运行中的容器（发送 SIGTERM 信号，允许容器保存数据后退出）。</p><p><strong>强制停止</strong>：若容器无法正常停止，可使用docker kill &lt;容器ID&gt;发送 SIGKILL 信号强制终止。</p><h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">rm</span> &lt;容器ID/名称&gt;<br></code></pre></td></tr></table></figure><p><strong>功能</strong>：删除已停止的容器（运行中的容器需先停止）。</p><p><strong>参数</strong>：-f可强制删除运行中的容器（docker rm -f &lt;容器ID&gt;），但可能导致数据丢失，谨慎使用。</p><h3 id="查看容器详情"><a href="#查看容器详情" class="headerlink" title="查看容器详情"></a>查看容器详情</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker inspect &lt;容器ID/名称&gt;<br></code></pre></td></tr></table></figure><p><strong>功能</strong>：显示容器的详细配置信息，包括网络设置、挂载点、环境变量、资源限制等。</p><p><strong>实用场景</strong>：查看容器的 IP 地址（NetworkSettings.IPAddress）、数据卷挂载路径（Mounts）等关键信息。</p><h2 id="学习小结"><a href="#学习小结" class="headerlink" title="学习小结"></a>学习小结</h2><p>今天系统学习了 Docker 的核心命令，从服务管理到镜像、容器操作，整体梳理了 Docker 的基础工作流程，也记录了一些实操中的问题和感悟：</p><ol><li><p><strong>核心逻辑梳理</strong>：</p><p>Docker 的核心体系可概括为 “三层结构” 与 “操作闭环”：</p><ol><li><strong>服务（Docker Daemon）</strong>：运行在主机上的守护进程，是所有 Docker 操作的基础支撑，负责管理镜像、容器、网络等资源。</li><li><strong>镜像（Image）</strong>：静态的只读模板，包含运行应用所需的完整文件系统（代码、依赖、配置等）和执行参数，可视为容器的 “源代码” 或 “类定义”。</li><li><strong>容器（Container）</strong>：镜像运行时的动态实例（类似 “对象”），是独立运行的应用单元。容器在镜像基础上新增可写层，所有运行时修改仅作用于该层，不影响原始镜像。</li></ol><p><strong>操作逻辑</strong>：<br>三者需遵循 “启动服务→管理镜像→操作容器” 的递进关系：</p><ul><li>必须先启动 Docker 服务（守护进程），才能执行后续操作；</li><li>镜像作为容器的 “模板”，需先构建或拉取镜像，才能基于其创建容器；</li><li>容器是应用的实际运行载体，所有业务操作最终通过容器实现。</li></ul></li><li><p><strong>关键命令掌握</strong>：</p><ul><li>服务管理：<code>systemctl start/stop/restart/status docker</code>是所有操作的前提，尤其要注意修改配置后需重启服务才生效。</li><li>镜像操作：<code>docker images/pull/rmi</code>能满足基本的镜像管理，学会用<code>镜像名称:标签</code>代替 ID 操作更直观，生产环境避免使用<code>latest</code>标签。</li><li>容器控制：<code>docker run</code>（创建启动）、<code>ps -a</code>（查看所有容器）、<code>exec -it</code>（进入容器）、<code>stop/rm</code>（停止删除）是高频组合，<code>-d</code>（后台运行）和<code>-p</code>（端口映射）参数对实际部署非常重要。</li></ul></li><li><p><strong>遇到的问题与解决思路</strong>：</p><ul><li>搜索镜像时出现网络超时（<code>i/o timeout</code>），推测是网络或镜像源问题，后续需尝试配置国内镜像源（如阿里云、网易）解决。</li><li>初期混淆了<code>docker run</code>和<code>docker start</code>的区别，实际操作后明确：<code>run</code>是 “新建 + 启动”，<code>start</code>是 “启动已存在容器”。</li><li>删除镜像时提示 “被容器引用”，理解了 “容器依赖镜像” 的关系，需先删容器再删镜像。</li></ul></li><li><p><strong>后续学习方向</strong>：</p><ul><li>解决网络问题，配置国内镜像源以提升拉取效率。</li><li>深入学习数据卷（<code>volume</code>），解决容器删除后数据丢失的问题。</li><li>尝试实际场景部署（如用 Docker 启动 Nginx、MySQL），巩固命令的组合使用。</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>容器技术</category>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决SpringBoot中Lombok注解失效的那些坑</title>
    <link href="/2025/08/13/%E8%A7%A3%E5%86%B3SpringBoot%E4%B8%ADLombok%E6%B3%A8%E8%A7%A3%E5%A4%B1%E6%95%88%E7%9A%84%E9%82%A3%E4%BA%9B%E5%9D%91/"/>
    <url>/2025/08/13/%E8%A7%A3%E5%86%B3SpringBoot%E4%B8%ADLombok%E6%B3%A8%E8%A7%A3%E5%A4%B1%E6%95%88%E7%9A%84%E9%82%A3%E4%BA%9B%E5%9D%91/</url>
    
    <content type="html"><![CDATA[<p>在 SpringBoot 项目开发中，Lombok 注解突然失效是一个很常见的问题，表现为明明添加了 @Data 等注解，却在编译时出现 “找不到符号”（如缺失 getter&#x2F;setter 方法）的错误。本文记录了我在项目中遇到该问题的排查过程，分析了 Lombok 注解失效与 Maven 编译插件（maven-compiler-plugin）配置、版本管理之间的关系，并总结了可行的解决方案和最佳实践。</p><span id="more"></span><h1 id="解决SpringBoot中Lombok注解失效的那些坑"><a href="#解决SpringBoot中Lombok注解失效的那些坑" class="headerlink" title="解决SpringBoot中Lombok注解失效的那些坑"></a>解决SpringBoot中Lombok注解失效的那些坑</h1><p>在开发SpringBoot项目时，相信很多同学都遇到过Lombok注解突然失效的问题：代码里明明加了<code>@Data</code>注解，编译时却报”找不到符号”（比如缺失getter&#x2F;setter方法）。最近我在项目中就遇到了类似问题，通过排查终于找到原因，在这里记录一下整个过程和解决方案。</p><h2 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h2><p>项目中使用了Lombok的<code>@Data</code>、<code>@Getter</code>等注解，但编译时出现一系列”找不到符号”错误：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cmd"><span class="hljs-function">java: 找不到符号</span><br><span class="hljs-function">  符号:   变量 <span class="hljs-title">log</span></span><br><span class="hljs-function">  位置: 类 <span class="hljs-title">org.hnu.tablerecognition.common.interceptor.JwtTokenInterceptor</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">java</span>: 找不到符号</span><br><span class="hljs-function">  符号:   方法 <span class="hljs-title">getRoleId</span>()</span><br><span class="hljs-function">  位置: 类型为<span class="hljs-title">xxx.UpdateRoleMenuDto</span>的变量 <span class="hljs-title">updateRoleMenuDto</span></span><br></code></pre></td></tr></table></figure><p>检查代码发现实体类确实添加了<code>@Data</code>注解，依赖也已引入，这就让人很困惑了。</p><h2 id="项目环境与配置"><a href="#项目环境与配置" class="headerlink" title="项目环境与配置"></a>项目环境与配置</h2><p>先看看我的项目依赖配置（pom.xml关键部分）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- Lombok依赖 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 其他依赖... --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 显式配置的编译插件 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">annotationProcessorPaths</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">path</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- 注意这里没有指定version --&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">annotationProcessorPaths</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-comment">&lt;!-- 配置... --&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>经过排查，发现问题主要出在三个方面：</p><h3 id="1-Lombok版本管理问题"><a href="#1-Lombok版本管理问题" class="headerlink" title="1. Lombok版本管理问题"></a>1. Lombok版本管理问题</h3><p>SpringBoot的<code>spring-boot-starter-parent</code>会统一管理大部分官方 starters 的版本，但<strong>Lombok并非SpringBoot官方组件</strong>，所以其版本不会被parent默认管理。</p><p>当在pom.xml中不指定Lombok版本时，Maven会尝试从依赖链中查找版本，但如果没有其他依赖间接引入Lombok，会导致：</p><ul><li>依赖版本缺失</li><li>引入低版本或不兼容版本</li></ul><p>这会直接导致编译时无法解析Lombok注解，出现”找不到符号”错误。</p><h3 id="2-maven-compiler-plugin的配置冲突"><a href="#2-maven-compiler-plugin的配置冲突" class="headerlink" title="2. maven-compiler-plugin的配置冲突"></a>2. maven-compiler-plugin的配置冲突</h3><p><code>maven-compiler-plugin</code>是Maven的编译插件，负责将Java源代码编译为字节码。我的问题就出在显式配置了这个插件，但存在两个问题：</p><ul><li>在<code>&lt;annotationProcessorPaths&gt;</code>中指定了Lombok却没有显式声明版本</li><li>手动配置覆盖了SpringBoot父工程的默认配置</li></ul><h3 id="3-Lombok的工作原理"><a href="#3-Lombok的工作原理" class="headerlink" title="3. Lombok的工作原理"></a>3. Lombok的工作原理</h3><p>Lombok通过<strong>Java注解处理器（Annotation Processor）</strong> 在编译时动态生成代码（如getter&#x2F;setter）。要使其生效，编译器必须能找到Lombok的注解处理器（包含在lombok.jar中）。</p><p>Maven中有两种方式指定注解处理器：</p><ul><li>显式配置：通过<code>maven-compiler-plugin</code>的<code>&lt;annotationProcessorPaths&gt;</code>指定</li><li>默认机制：自动从项目依赖中寻找包含注解处理器的JAR包</li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>注释掉手动配置的<code>maven-compiler-plugin</code>后，问题得到解决：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 注释掉手动配置的编译插件 --&gt;</span><br>    <span class="hljs-comment">&lt;!-- &lt;plugin&gt;</span><br><span class="hljs-comment">      &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="hljs-comment">      &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="hljs-comment">      &lt;configuration&gt;</span><br><span class="hljs-comment">        &lt;annotationProcessorPaths&gt;</span><br><span class="hljs-comment">          &lt;path&gt;</span><br><span class="hljs-comment">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="hljs-comment">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="hljs-comment">          &lt;/path&gt;</span><br><span class="hljs-comment">        &lt;/annotationProcessorPaths&gt;</span><br><span class="hljs-comment">      &lt;/configuration&gt;</span><br><span class="hljs-comment">    &lt;/plugin&gt; --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-comment">&lt;!-- 配置... --&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><p>为什么这样就行？因为：</p><ol><li><p><strong>SpringBoot父工程已包含默认配置</strong>：<code>spring-boot-starter-parent</code>已经内置了<code>maven-compiler-plugin</code>的默认配置，包括对注解处理器的支持</p></li><li><p><strong>默认机制会自动发现Lombok</strong>：Lombok的JAR包中包含<code>META-INF/services/javax.annotation.processing.Processor</code>文件，声明了它是注解处理器，父工程的默认配置会自动扫描并使用</p></li><li><p><strong>避免了版本冲突</strong>：注释掉手动配置后，Maven会使用依赖中声明的Lombok版本，不会出现版本不匹配问题</p></li></ol><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>为了避免类似问题，总结几个最佳实践：</p><ol><li><strong>明确指定Lombok版本</strong>：即使依赖管理正常，显式指定版本也能提高项目稳定性</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.18.24<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span> <span class="hljs-comment">&lt;!-- 明确版本 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li><p><strong>正确配置IDE</strong>：确保IDEA安装了Lombok插件并启用注解处理器</p><ul><li>安装插件：<code>File -&gt; Settings -&gt; Plugins</code>搜索Lombok</li><li>启用注解处理：<code>File -&gt; Settings -&gt; Build, Execution, Deployment -&gt; Compiler -&gt; Annotation Processors</code>勾选<code>Enable annotation processing</code></li></ul></li><li><p><strong>合理使用父工程配置</strong>：对于SpringBoot项目，优先使用<code>spring-boot-starter-parent</code>提供的默认配置，除非有特殊需求，否则不要重复声明<code>maven-compiler-plugin</code></p></li><li><p><strong>需要自定义编译配置时</strong>：如果必须手动配置<code>maven-compiler-plugin</code>，确保注解处理器路径配置完整</p></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">annotationProcessorPaths</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">path</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.18.24<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span> <span class="hljs-comment">&lt;!-- 与依赖版本一致 --&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">annotationProcessorPaths</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Lombok注解失效问题看似复杂，实则大多与版本管理和编译配置有关。理解Maven的依赖管理机制、注解处理器工作原理以及SpringBoot父工程的默认配置，能帮助我们快速定位并解决这类问题。</p><p>记住：大多数时候，使用SpringBoot提供的默认配置就足够了，不要过度自定义配置，以免引入不必要的问题。</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>SpringBoot</category>
      
      <category>问题解决</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
      <tag>Lombok</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2025/08/09/hello-world/"/>
    <url>/2025/08/09/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
